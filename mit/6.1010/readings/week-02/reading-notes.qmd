---
title: MIT 6.1010 - Week 2 Notes
format: html
jupyter: python3
---

Topics covered in this lecture:
- Functions
- Abstractions
- First-Class Objects
- Closures

# Functions

## Introduction

- Provide a means of representing the abstract notion of an arbitrary computation

## Power of Abstraction

- Primatives
  - What are the smallest and simplest building blocks of which the system is comprised?
  - Python has several:
    - Arithmetic: `+`, `-`, `*`, etc.
    - Comparisons: `==`, `!=`, etc.
    - Boolean: `and`, `or`, etc.
    - Build-in functions: `abs`, `len`, etc.
- Means of Combinations
  - How can we combine these building blcoks together to build more complicated compound structures?
    - In Python, it would be using:
      - Conditionals: `if`, `elif`, `else`, etc.
      - Looping Structures: `for`, `while`, etc.
      - Function Composition: `f(g(x))`
- Means of Abstraction
  - What mechanisms do we have for treating those complicated compound structures as building blocks themselves?
    - In Python, define functions using the `def` or `lambda` keywords

## Functions & The Environmental Model

- Function definition with `def`
  - The keyword in Python does two things:
    1. Creates a new function object in the Heap that contains
         - The "formal parameters" of the function (internal names of the arguments)
         - The code in the body of the function
         - A reference to the frame in which code was running when the `def` keyword was encountered
    2. Associates that function object with a name in the frame that was running when the `def` keyword was encountered
  - In the following function:
    - The name `quad_eval` is stored in the Stack in the Global Frame
    - A pointer from `quad_eval` in the Stack points to a function object in the Heap
    - This function object contains
      - Formal parameters `a`, `b`, `c`, and `v`
      - The code of the function itself
      - A reference back to the Global Frame since that is the frame in which the `def` keyword was encountered

```{python}
def quad_eval(a, b, c, v):
  """
  Given coefficients a, b, and c representing a quadratic polynomial:
    ax^2 + bx + c
  as well as a value v, return the value of the polynomial at the given point
  """
  term1 = a * v ** 2
  term2 = b * v

  return term1 + term2 + c
```

- Functions objects are called a "first-class" object
  - The object is treated similarly to how other objects are treated
  - The variable binding made with `def` is the exact same kind of reference as made when decalring `int` objects, for example
- Function objects are only really useful when we "call" (also "apply" or "invoke") them, which consists of four steps in Python
  1. Evaluate the function to be called, followed by its arguments (in order) in the frame from which the call is being made
  2. Create a new frame for the function call, which will be used to store the variables local to the functino call
       - This new frame has a "parent pointer" back to the function's enclosing frame
  3. Bind the names of the formal parameters of the function to the arguments that were passed in inside of the new frame just created
  4. Execute the body of the function in the new frame
       - Note that if a name that is not bound to the frame is evaluated, Python will look for it in the "parent" frame as well

```{python}
def quad_eval(a, b, c, v):
  term1 = a * v ** 2
  term2 = b * v

  return term1 + term2 + c

n = quad_eval(7, 8, 9, 3)
print(n)
```

- There is a distinction between arguments and parameters:
  - Parameters (sometimes called formal parameters or formals): variables used inside a function
  - Arguments (sometimes called actual parameters or actuals): values that are passed when the function is called, becoming the values of the parameters as the body of the function starts executing

```{python}
x = 500

def foo(y):
  return x + y

z = foo(307)

print('x:', x)
print('z:', z)
print('foo', foo)

print()

def bar(x):
  x = 1000
  
  return foo(308)

w = bar(349)

print('x:', x)
print('w:', w)
```

## Functions Are "First-Class" Objects

- Functions in Python can be manipulated in many ways that other data can
  - Passed as arguments to functions
  - Defined inside of other functions
  - Returned from other functions
  - Added to collections
  - Bound to variables
- Reflected in environment diagrams by representing functions as functions on the right-side of diagrams
  - The function object is created on the heap and points back to the stack environment
  - The name `double` is added to the stack and a pointer points from `double` to the function
  - The name `myFunc` is added to the stack and points to the same function on the heap

```{python}
def double(x):
  return 2 * x

myFunc = double
```

- Another example below:
  - The function object is created on the heap and points back to the stack environment
  - The name `square` is added to the stack and a pointer points from `square` to the function
  - The name `foo` is added to the stack and a pointer points from `foo` to the function
  - Two blocks of memory is added to the heap and a pointer from each block points to the function
  - The name `x` is added to the stack and a pointer points from `x` to the blocks of memory

```{python}
def square(x):
  return x * x

foo = square

x = [square, foo]
```

- Functions can also be passed as arguments to other functions
  - Note that in `for` loops we can use `_` for the name of a variable we do not actually use

```{python}
def apply_n_times(f, n, x):
  out = x
  for _ in range(n):
    out = f(out)
  
  return out

apply_n_times(square, n=4, x=3)
```

- Can use lambda functions when functions are passed as arguments
  - For example, a lambda function version of `square`: `lambda x: x * x`

```{python}
apply_n_times(lambda x: x * x, n=4, x=3)
```

- Example of use: plotting with `matplotlib`
  - Can plot sines

```{python}
import math
import matplotlib.pyplot as plt

def sine_response(lo, hi, step):
  xs = []
  ys = []

  cur = lo
  while cur <= hi:
    xs.append(cur)
    ys.append(math.sin(cur))
    cur += step
  
  plt.plot(xs, ys)

sine_response(-5, 5, 0.1)
```

  - Can plot cosines

```{python}
def cosine_response(lo, hi, step):
  xs = []
  ys = []

  cur = lo
  while cur <= hi:
    xs.append(cur)
    ys.append(math.cos(cur))
    cur += step
  
  plt.plot(xs, ys)

cosine_response(-5, 5, 0.1)
```

  - But maybe we want to plot something else too

```{python}
def square_response(lo, hi, step):
  xs = []
  ys = []

  cur = lo
  while cur <= hi:
    xs.append(cur)
    ys.append(cur ** 2)
    cur += step
  
  plt.plot(xs, ys)

square_response(-5, 5, 0.1)
```

  - A lot of repeated code, so can simplify by passing a function as an argument

```{python}
def response(f, lo, hi, step):
  xs = []
  ys = []
  
  cur = lo
  while cur <= hi:
    xs.append(cur)
    ys.append(f(cur))
    cur += step
  
  plt.plot(xs, ys)

def square(x):
  return x ** 2
```

```{python}
response(square, 0, 5, 0.001)
```

```{python}
response(lambda x: x ** 3, 0, 5, 0.001)
```

```{python}
response(math.sin, 0, 10, 0.01)
```

- The following code will result in five 16's being printed... by why?
  - This is because, once the loop has finished, the variable `i` is equal to four
  - The function saved in the `functions` list does not replace `i` with its current value, it keeps it as `i`
  - Therefore, each function is `return x + i` and since `i = 4` and `x = 12`, each will return `16`

```{python}
functions = []
for i in range(5):
  def func(x):
    return x + i
  
  functions.append(func)

for f in functions:
  print(f(12))
```

## Closures

- A function object "remembers" the frame in which it was defined (enclosing frame)
- When a function is called later, it has access to the variables defined in that frame
- The combination of a function and its enclosing frame is a "closure"

- In the example below:
  - First `print` will be 0 since that is defined in the global frame
  - Call to `outer()` will first call `inner()`
    - Since `x` is not defined in `inner()`, it goes up to the `outer()` frame
    - Since `x` is defined there as 1, it prints it
  - Once `inner()` is called, the last line then prints `x` as it is defined in the current frame, which is 1
  - Finally, printing `x` in the global frame will again print 0 that is the value of `x` in the global frame

```{python}
x = 0

def outer():
  x = 1

  def inner():
    print("inner:", x)
  
  inner()

  print("outer:", x)

print("global:", x)
outer()
# inner() #> Will not work because `inner()` is only defined in the frame of `outer()`
print("global:", x)
```

- One final example that fixes an earlier problem
  - Since the variable `i` is evaluated in each loop, each function's closure records the value

```{python}
def make_adder(n):
  return lambda x: x + n

functions = []
for i in range(5):
  functions.append(make_adder(i))

for f in functions:
  print(f(12))
```