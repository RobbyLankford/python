---
title: MIT 6.1010 - Week 4 Notes
format: html
jupyter: python3
---

Topics Covered in this lecture:
- 

# Recursive Patterns

## Definitions

- **Recursion**: occurs when something is defined is terms of itself, usually made up of
    1. **Base case**: terminating scenario that does not need recursion to produce an answer
    2. **Recursive case**: sets of rules that reduce all other cases toward base case

- Python allows us to define functions recursively

```{python}
# Calculating a Factorial
def factorial(n):
    #> Base Case
    if n == 0:
        return 1
    
    #> Recursive Case
    else:
        return n * factorial(n - 1)
```

```{python}
print(factorial(n=3))
```

## Example - Logging

- The function below defines whether a given value can be a log entry
    - It defines a "valid log entry" in a way that *depends* on the definition of a valid log entry, making it an excellent candidate for recursion

```{python}
def can_log(x):
    """
    Checks whether a given value can be a log entry.
    Valid log entries are strings/bytestrings, ints, floats, complex numbers,
    None, of Booleans; __or__ lists, tuples, sets, frozensets, dicts, or 
    OrderedDicts containing only valid log entries.
    """

    #> Base case #1: valid atomic elements
    if isinstance(x, (str, bytes, int, float, complex, NoneType, bool)):
        return True
    
    #> Recursive case #1: need to check the individual elements
    elif isinstance(x, (list, tuple, set, frozenset)):
        return all(can_log(v) for v in x)
    
    #> Recursive case #2: special case for dictionaries
    elif isinstance(x, (dict, OrderedDict)):
        return all((can_log(k) and can_log(v)) for k,v in x.items())
    
    #> Base case #2: invalid atomic elements
    return False
```

## Example - Summing a List

- Iterative solution to summing items in a list

```{python}
def sum_list(x):
    out = 0
    for num in x:
        out += num
    
    return out
```

- Recursive solution to summing items in a list
    - Tradeoffs between iteration and recursion will be discussed in future reading notes

```{python}
def sum_list(x):
    if len(x) == 1:
        return x[0]
    else:
        return x[0] + sum_list(x[1: ])
```

- Not quite right because the base case of an empty list is not handled properly

```{python}
def sum_list(x):
    if len(x) == 0:
        return 0
    elif len(x) == 1:
        return x[0]
    else:
        return x[0] + sum_list(x[1: ])
```

- But now the code is doing too much work, it is not DRY, so can simplify further

```{python}
def sum_list(x):
    if len(x) == 0:
        return 0
    else:
        return x[0] + sum_list(x[1: ])
```

## Example - Summing a Nested List

- A more difficult problem because numbers may be inside sublists, down to an arbitrary depth
    - Need to decide if the next element is a number of a sublist
    - Can call recursively twice in the same line to help solve this problem
    - As long as we are splitting the problem into *smaller* and *simpler* steps, it will work

```{python}
def sum_nested(x):
    
    #> Base Case
    if not x:
        return 0
    
    #> Recursive Case #1: lists will continue to drop here until they are split into atomic values
    elif isinstance(x[0], list):
        return sum_nested(x[0]) + sum_nested(x[1: ])
    
    #> Recursive Case #2: for atomic values
    else:
        return x[0] + sum_nested(x[1: ])
```

## Choosing the Right Decomposition

- Recursion is only an elegant solution for some problems, not all of them
    - Often involves splitting the problem into *smaller* and *simpler* pieces

### Example - Subsequences

```{python}
def subsequences(seq):
    if not seq:
        #> Base Case: subsequences of an empty sequence is the set with just that sequence
        return {()}
    else:
        #> Recursive Case: split seq into two smaller sequences
        first = seq[0]
        rest = seq[1: ]

        #> Recursively find all possible subsequences in rest
        rest_seq = subsequences(rest)

        #> Iteratively combine first with all subsequences in rest
        first_seq = {(first, ) + sub_seq for sub_seq in rest_seq}

        # Final result is combination of all subsequences with and without first
        return first_seq | rest_seq
```

```{python}
print(subsequences([4, 2, 3]))
```

## Choosing the Right Recursive Subproblem

- The recursive subproblem can be smaller or simpler in more subtle ways than just the value of a numeric parameter
    - For example, reducing a problem from *all* integers to only *positive* integers
- In general, think about several ways to break down the problem and try to write the recursive cases
    - Find the one that produces the simplest, most natural recursive case

```{python}
def number_to_string(n, b):
    """
    Given an integer n and base b (where 2 <= b <= 10),
    returns n represented as a string in base-b notation.
    """
    digits = "0123456789"

    if n < 0:
        return "-" + number_to_string(-n, b)
    elif n < b:
        return str(n)
    else:
        return number_to_string(n // b, b) + digits[n % b]
```

```{python}
print(number_to_string(-829, 10))
print(number_to_string(5, 2))
print(number_to_string(0, 10))
```